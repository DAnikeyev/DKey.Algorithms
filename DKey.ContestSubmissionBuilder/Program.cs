using System.Text;
using DKey.Algorithms.DataStructures.Graph.DepthFirstSearch;
using DKey.Algorithms.TextProcessing;
using SubmissionBuilder;

namespace CodeForcesSubmissionBuilder;

public class Program
{
    private static Dictionary<string, string> _classToPath = new ();
    private static Dictionary<string, int> _classToIndex = new ();
    private static Dictionary<string, string> _classToImplementation = new ();
    private static Dictionary<string, HashSet<string>> _classToUsings = new ();
    private static List<string> _keys = new ();
    private static Dictionary<string, int> _priority = new ()
    {
        {"Program", 2},
        {"IOHelper", -3},
        {"LinqExtension", -1},
        {"Solver", -2},
        {"MultiSolver", -2},
    };
    
    /// <summary>
    /// Builds a single .cs file with all the dependencies starting from program.cs of DKey.CodeForces.
    /// </summary>
    public static void Main()
    {
        var graph = BuildDependencies();
        var context = new DFSContext(graph, _classToIndex[Config.Root]);
        DFS.Recursive(context);
        var classIndexes = context.Used;
        File.WriteAllText(Config.SubmissionPath, BuildSubmission(classIndexes));
    }

    private static string BuildSubmission(HashSet<int> classIndexes)
    {
        var sb = new StringBuilder();
        sb.AppendLine(@"//██████╗ ██╗  ██╗███████╗██╗   ██╗      █████╗ ██╗      ██████╗  ██████╗ ██████╗ ██╗████████╗██╗  ██╗███╗   ███╗███████╗");
        sb.AppendLine(@"//██╔══██╗██║ ██╔╝██╔════╝╚██╗ ██╔╝     ██╔══██╗██║     ██╔════╝ ██╔═══██╗██╔══██╗██║╚══██╔══╝██║  ██║████╗ ████║██╔════╝");
        sb.AppendLine(@"//██║  ██║█████╔╝ █████╗   ╚████╔╝      ███████║██║     ██║  ███╗██║   ██║██████╔╝██║   ██║   ███████║██╔████╔██║███████╗");
        sb.AppendLine(@"//██║  ██║██╔═██╗ ██╔══╝    ╚██╔╝       ██╔══██║██║     ██║   ██║██║   ██║██╔══██╗██║   ██║   ██╔══██║██║╚██╔╝██║╚════██║");
        sb.AppendLine(@"//██████╔╝██║  ██╗███████╗   ██║   ██╗  ██║  ██║███████╗╚██████╔╝╚██████╔╝██║  ██║██║   ██║   ██║  ██║██║ ╚═╝ ██║███████║");
        sb.AppendLine(@"//╚═════╝ ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚═╝  ╚═╝  ╚═╝╚══════╝ ╚═════╝  ╚═════╝ ╚═╝  ╚═╝╚═╝   ╚═╝   ╚═╝  ╚═╝╚═╝     ╚═╝╚══════╝");
        sb.AppendLine(@"//https://github.com/DAnikeyev/DKey.Algorithms");
        sb.AppendLine(@"//This file is auto-generated by DKey.ContestSubmissionBuilder.");
        sb.AppendLine(@"//Might contain some unused methods.");
        sb.AppendLine();

        var usings = classIndexes.Select(x => _classToUsings[_keys[x]]).SelectMany(x => x).ToHashSet();
        foreach (var u in usings)
        {
            sb.AppendLine(u);
        }

        sb.AppendLine();
        sb.AppendLine("namespace Submission;");
        sb.AppendLine();
        sb.AppendLine(string.Join("\r\n\r\n", classIndexes.OrderByDescending(x => Priority(_keys[x])).Select(x => _classToImplementation[_keys[x]])));
        return sb.ToString();
    }

    private static int Priority(string key)
    {
        if (_priority.TryGetValue(key, out var priority))
            return priority;
        if (key.StartsWith("Solver"))
            return 1;
        return 0;
    }

    public static List<int>[] BuildDependencies()
    {
        foreach (var folder in Config.FoldersToExplore)
        {
            var folderPath = Path.Combine(Config.RepoPath, folder);
            foreach (var filePath in Directory.EnumerateFiles(folderPath, "*.cs", SearchOption.AllDirectories))
            {
                var className = Path.GetFileNameWithoutExtension(filePath);
                if (Config.FoldersToExclude.Any(filePath.Contains) || Config.ExcludedClasses.Any(className.Contains) || _classToPath.ContainsKey(className))
                    continue;
                _keys.Add(className);
                _classToIndex.Add(className, _keys.Count - 1);
                _classToPath.Add(className, filePath);
            }
        }

        var size = _keys.Count;
        var graph = new List<int>[size];
        for(var i = 0; i < _keys.Count; i++)
        {
            var key = _keys[i];
            graph[i] = ParseClass(key, File.ReadAllLines(_classToPath[key]));
        }

        return graph;
    }

    private static List<int> ParseClass(string key, string[] lines)
    {
        var childIndexes = new HashSet<int>();
        _classToUsings[key] = new HashSet<string>();
        var index = 0;
        while (true)
        {
            var line = lines[index].Trim();
            if (line.Contains("using"))
            {
                if(!line.Contains("DKey"))
                    _classToUsings[key].Add(line);
                foreach (var dependency in Config.PrimitiveExtensions.Where(x => line.Contains(x)))
                {
                    if(_classToIndex.TryGetValue(dependency, out var dependencyIndex))
                        childIndexes.Add(dependencyIndex);
                }
            }

            if (line.Contains("namespace") || line.Contains("class") || line.Contains("enum") || line.Contains("struct") || line.Contains("interface"))
                break;
            index++;
        }

        while (index < lines.Length && !lines[index].Contains("class") && !lines[index].Contains("enum") && !lines[index].Contains("struct") && !lines[index].Contains("interface"))
            index++;

        var implementation = string.Join("\n", lines.Skip(index));
        _classToImplementation[key] = implementation;
        
        //Search dependencies inside a class excluding comments.
        var tokens = Tokenizer.Split(string.Join("\n", lines.Skip(index).Select(x => x.Trim()).Where(x => !x.StartsWith(@"//"))), TokenizerMode.TakeOnlyLettersOrDigit);
        foreach (var t in tokens)
        {
            if (t == key)
                continue;
            if(_classToIndex.TryGetValue(t, out var dependencyIndex))
                childIndexes.Add(dependencyIndex);
        }

        return childIndexes.ToList();
    }
}